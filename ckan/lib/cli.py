import os
import datetime
import sys
import logging
from pprint import pprint
import re
import cloghandler

import paste.script
from paste.registry import Registry
from paste.script.util.logging_config import fileConfig

try:
    import cloghandler    
except ImportError:
    pass

#NB No CKAN imports are allowed until after the config file is loaded.
#   i.e. do the imports in methods, after _load_config is called.
#   Otherwise loggers get disabled.

class MockTranslator(object):
    def gettext(self, value):
        return value

    def ugettext(self, value):
        return value

    def ungettext(self, singular, plural, n):
        if n > 1:
            return plural
        return singular

class CkanCommand(paste.script.command.Command):
    parser = paste.script.command.Command.standard_parser(verbose=True)
    parser.add_option('-c', '--config', dest='config',
            default='development.ini', help='Config file to use.')
    parser.add_option('-f', '--file',
        action='store',
        dest='file_path',
        help="File to dump results to (if needed)")
    default_verbosity = 1
    group_name = 'ckan'

    def _load_config(self, load_environment=True):
        '''Load pylons environment configured with CKAN config file'''
        from paste.deploy import appconfig
        if not self.options.config:
            msg = 'No config file supplied'
            raise self.BadCommand(msg)
        self.filename = os.path.abspath(self.options.config)
        if not os.path.exists(self.filename):
            raise AssertionError('Config filename %r does not exist.' % self.filename)
        fileConfig(self.filename)
        conf = appconfig('config:' + self.filename)
        assert 'ckan' not in dir() # otherwise loggers would be disabled

        if load_environment:
            # We have now loaded the config. Now we can import ckan for the
            # first time.
            from ckan.config.environment import load_environment
            load_environment(conf.global_conf, conf.local_conf)

            self.registry=Registry()
            self.registry.prepare()
            import pylons
            self.translator_obj = MockTranslator()
            self.registry.register(pylons.translator, self.translator_obj)
        else:
            # Initialize config with the basic options
            import pylons
            pylons.config.init_app(conf.global_conf, conf.local_conf,
                                   package='ckan', paths=[])

    def _setup_app(self):
        cmd = paste.script.appinstall.SetupCommand('setup-app')
        cmd.run([self.filename])


class CachedReports(CkanCommand):
    """
    Pre-generates slow running reports and caches them

    All reports are generated by any plugin that implements
    ICachedReport, but this can be constrained by providing
    a command separated list of key names on the command-line
    and only those reports that can handle the named report will
    be run.

    The two available commands are:

        list - Lists all of the registered reports

        generate - Will generate all of the reports, or if a 
        comma-separated list is supplied will run only those reports

    Example,

      Generate two reports:
      paster cache-reports generate openness-scores,another -c development.ini

      Generate all reports:
      paster cache-reports generate -c development.ini

      List all reports:
      paster cache-reports list -c development.ini

    """

    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 2
    min_args = None

    def __init__(self,name):
        super(CachedReports,self).__init__(name)

    def command(self):
        self._load_config()
        self.log = logging.getLogger("ckan.lib.cli")

        import ckan.model as model

        if not self.args:
            self.log.error("No arguments supplied and they are required")
            sys.stderr.write(self.usage)
            return
        else:
            cmd = self.args[0]
            if cmd == 'list':
                self._list()
            elif cmd == 'generate':
                report_list = None
                if len(self.args) == 2:
                    report_list = [s.strip() for s in self.args[1].split(',')]
                    self.log.info("Running reports => %s", report_list)
                self._generate(report_list)
        
    def _list(self):
        import ckan.plugins as p
        for plugin in p.PluginImplementations(p.ICachedReport):
            self.log.info("Reports in %s" % plugin.name)
            keys = plugin.list_report_keys()
            for k in keys:
                self.log.info(" - %s" % k)

    def _generate(self, report_list=None):
        import ckan.plugins as p

        for plugin in p.PluginImplementations(p.ICachedReport):
            self.log.info("Looking for reports in %r" % plugin)
            reports = plugin.register_reports()

            for k,v in reports.iteritems():
                v(report_list)



class ManageDb(CkanCommand):
    '''Perform various tasks on the database.

    db create # alias of db upgrade
    db init # create and put in default data
    db clean
    db upgrade [{version no.}] # Data migrate
    db version # returns current version of data schema
    db dump {file-path} # dump to a pg_dump file
    db dump-rdf {dataset-name} {file-path}
    db simple-dump-csv {file-path} # dump just datasets in CSV format
    db simple-dump-json {file-path} # dump just datasets in JSON format
    db user-dump-csv {file-path} # dump user information to a CSV file
    db send-rdf {talis-store} {username} {password}
    db load {file-path} # load a pg_dump from a file
    db load-only {file-path} # load a pg_dump from a file but don\'t do
                             # the schema upgrade or search indexing
    db create-from-model # create database from the model (indexes not made)
    '''
    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = None
    min_args = 1

    def command(self):
        self._load_config()
        import ckan.model as model
        import ckan.lib.search as search

        cmd = self.args[0]
        if cmd == 'init':
            model.repo.init_db()
            if self.verbose:
                print 'Initialising DB: SUCCESS'
        elif cmd == 'clean' or cmd == 'drop':
            model.repo.clean_db()
            search.clear()
            if self.verbose:
                print 'Cleaning DB: SUCCESS'
        elif cmd == 'upgrade':
            if len(self.args) > 1:
                model.repo.upgrade_db(self.args[1])
            else:
                model.repo.upgrade_db()
        elif cmd == 'version':
            self.version()
        elif cmd == 'dump':
            self.dump()
        elif cmd == 'load':
            self.load()
        elif cmd == 'load-only':
            self.load(only_load=True)
        elif cmd == 'simple-dump-csv':
            self.simple_dump_csv()
        elif cmd == 'simple-dump-json':
            self.simple_dump_json()
        elif cmd == 'dump-rdf':
            self.dump_rdf()
        elif cmd == 'user-dump-csv':
            self.user_dump_csv()
        elif cmd == 'create-from-model':
            model.repo.create_db()
            if self.verbose:
                print 'Creating DB: SUCCESS'
        elif cmd == 'send-rdf':
            self.send_rdf()
        else:
            print 'Command %s not recognized' % cmd
            sys.exit(1)

    def _get_db_config(self):
        from pylons import config
        url = config['sqlalchemy.url']
        # e.g. 'postgres://tester:pass@localhost/ckantest3'
        db_details_match = re.match('^\s*(?P<db_type>\w*)://(?P<db_user>[^:]*):?(?P<db_pass>[^@]*)@(?P<db_host>[^/:]*):?(?P<db_port>[^/]*)/(?P<db_name>[\w.-]*)', url)
        if not db_details_match:
            raise Exception('Could not extract db details from url: %r' % url)
        db_details = db_details_match.groupdict()
        return db_details

    def _get_postgres_cmd(self, command):
        self.db_details = self._get_db_config()
        if self.db_details.get('db_type') not in ('postgres', 'postgresql'):
            raise AssertionError('Expected postgres database - not %r' % self.db_details.get('db_type'))
        pg_cmd = command
        pg_cmd += ' -U %(db_user)s' % self.db_details
        if self.db_details.get('db_pass') not in (None, ''):
            pg_cmd = 'export PGPASSWORD=%(db_pass)s && ' % self.db_details + pg_cmd
        if self.db_details.get('db_host') not in (None, ''):
            pg_cmd += ' -h %(db_host)s' % self.db_details
        if self.db_details.get('db_port') not in (None, ''):
            pg_cmd += ' -p %(db_port)s' % self.db_details
        return pg_cmd

    def _get_psql_cmd(self):
        psql_cmd = self._get_postgres_cmd('psql')
        psql_cmd += ' -d %(db_name)s' % self.db_details
        return psql_cmd

    def _postgres_dump(self, filepath):
        pg_dump_cmd = self._get_postgres_cmd('pg_dump')
        pg_dump_cmd += ' %(db_name)s' % self.db_details
        pg_dump_cmd += ' > %s' % filepath
        self._run_cmd(pg_dump_cmd)
        print 'Dumped database to: %s' % filepath

    def _postgres_load(self, filepath):
        import ckan.model as model
        assert not model.repo.are_tables_created(), "Tables already found. You need to 'db clean' before a load."
        pg_cmd = self._get_psql_cmd() + ' -f %s' % filepath
        self._run_cmd(pg_cmd)
        print 'Loaded CKAN database: %s' % filepath

    def _run_cmd(self, command_line):
        import subprocess
        retcode = subprocess.call(command_line, shell=True)
        if retcode != 0:
            raise SystemError('Command exited with errorcode: %i' % retcode)

    def dump(self):
        if len(self.args) < 2:
            print 'Need pg_dump filepath'
            return
        dump_path = self.args[1]

        psql_cmd = self._get_psql_cmd() + ' -f %s'
        pg_cmd = self._postgres_dump(dump_path)

    def load(self, only_load=False):
        if len(self.args) < 2:
            print 'Need pg_dump filepath'
            return
        dump_path = self.args[1]

        psql_cmd = self._get_psql_cmd() + ' -f %s'
        pg_cmd = self._postgres_load(dump_path)
        if not only_load:
            print 'Upgrading DB'
            import ckan.model as model
            model.repo.upgrade_db()

            print 'Rebuilding search index'
            import ckan.lib.search
            ckan.lib.search.rebuild()
        else:
            print 'Now remember you have to call \'db upgrade\' and then \'search-index rebuild\'.'
        print 'Done'

    def simple_dump_csv(self):
        import ckan.model as model
        if len(self.args) < 2:
            print 'Need csv file path'
            return
        dump_filepath = self.args[1]
        import ckan.lib.dumper as dumper
        dump_file = open(dump_filepath, 'w')
        dumper.SimpleDumper().dump(dump_file, format='csv')

    def simple_dump_json(self):
        import ckan.model as model
        if len(self.args) < 2:
            print 'Need json file path'
            return
        dump_filepath = self.args[1]
        import ckan.lib.dumper as dumper
        dump_file = open(dump_filepath, 'w')
        dumper.SimpleDumper().dump(dump_file, format='json')

    def dump_rdf(self):
        if len(self.args) < 3:
            print 'Need dataset name and rdf file path'
            return
        package_name = self.args[1]
        rdf_path = self.args[2]
        import ckan.model as model
        import ckan.lib.rdf as rdf
        pkg = model.Package.by_name(unicode(package_name))
        if not pkg:
            print 'Dataset name "%s" does not exist' % package_name
            return
        rdf = rdf.RdfExporter().export_package(pkg)
        f = open(rdf_path, 'w')
        f.write(rdf)
        f.close()

    def user_dump_csv(self):
        if len(self.args) < 2:
            print 'Need csv file path'
            return
        dump_filepath = self.args[1]
        import ckan.lib.dumper as dumper
        dump_file = open(dump_filepath, 'w')
        dumper.UserDumper().dump(dump_file)

    def send_rdf(self):
        if len(self.args) < 4:
            print 'Need all arguments: {talis-store} {username} {password}'
            return
        talis_store = self.args[1]
        username = self.args[2]
        password = self.args[3]
        import ckan.lib.talis
        talis = ckan.lib.talis.Talis()
        return talis.send_rdf(talis_store, username, password)

    def version(self):
        from ckan.model import Session
        print Session.execute('select version from migrate_version;').fetchall()


class SearchIndexCommand(CkanCommand):
    '''Creates a search index for all datasets

    Usage:
      search-index [-i] [-o] [-r] rebuild [dataset-name]     - reindex dataset-name if given, if not then rebuild full search index (all datasets)
      search-index check                                     - checks for datasets not indexed
      search-index show {dataset-name}                       - shows index of a dataset
      search-index rebuild-publisher {publisher-name}        - Rebuilds the publisher\'s datasets index
      search-index clear [dataset-name]                      - clears the search index for the provided dataset or for the whole ckan instance
    '''

    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 2
    min_args = 0

    def __init__(self,name):

        super(SearchIndexCommand,self).__init__(name)

        self.parser.add_option('-i', '--force', dest='force',
            action='store_true', default=False, help='Ignore exceptions when rebuilding the index')

        self.parser.add_option('-o', '--only-missing', dest='only_missing',
            action='store_true', default=False, help='Index non indexed datasets only')

        self.parser.add_option('-r', '--refresh', dest='refresh',
            action='store_true', default=False, help='Refresh current index (does not clear the existing one)')

    def command(self):
        self._load_config()

        if not self.args:
            # default to printing help
            print self.usage
            return

        cmd = self.args[0]
        if cmd == 'rebuild':
            self.rebuild()
        elif cmd == 'rebuild-publisher':
            self.rebuild_publisher()
        elif cmd == 'check':
            self.check()
        elif cmd == 'show':
            self.show()
        elif cmd == 'clear':
            self.clear()
        else:
            print 'Command %s not recognized' % cmd

    def rebuild_publisher(self):
        from ckan.model import Session, Group, Member, Package
        from ckan.lib.search import rebuild as rebuild_package

        if len(self.args) <= 1:
            print 'No publisher name was specified'
            sys.exit(0)

        publisher = Group.get(self.args[1])
        if not publisher:
            print 'Publisher (%s) was not found' % self.args[1]
            sys.exit(0)

        members = Session.query(Member).filter(Member.group_id==publisher.id).\
            filter(Member.state=='active').filter(Member.table_name=='package')

        for member in members.all():
            package = Package.get(member.table_id)
            if not package:
                print 'Package (%s) was not found in (%s)' % (member.table_id, member,)
                continue

            print 'Rebuilding index: %s' % package.name
            rebuild_package(package.name)


    def rebuild(self):
        from ckan.lib.search import rebuild

        if len(self.args) > 1:
            rebuild(self.args[1])
        else:
            rebuild(only_missing=self.options.only_missing,
                    force=self.options.force,
                    refresh=self.options.refresh)
    def check(self):
        from ckan.lib.search import check

        check()

    def show(self):
        from ckan.lib.search import show

        if not len(self.args) == 2:
            print 'Missing parameter: dataset-name'
            return
        index = show(self.args[1])
        pprint(index)

    def clear(self):
        from ckan.lib.search import clear

        package_id =self.args[1] if len(self.args) > 1 else None
        clear(package_id)

class Notification(CkanCommand):
    '''Send out modification notifications.

    In "replay" mode, an update signal is sent for each dataset in the database.

    Usage:
      notify replay                        - send out modification signals
    '''

    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 1
    min_args = 0

    def command(self):
        self._load_config()
        from ckan.model import Session, Package, DomainObjectOperation
        from ckan.model.modification import DomainObjectModificationExtension

        if not self.args:
            # default to run
            cmd = 'replay'
        else:
            cmd = self.args[0]

        if cmd == 'replay':
            dome = DomainObjectModificationExtension()
            for package in Session.query(Package):
                dome.notify(package, DomainObjectOperation.changed)
        else:
            print 'Command %s not recognized' % cmd


class RDFExport(CkanCommand):
    '''
    This command dumps out all currently active datasets as RDF into the
    specified folder.

    Usage:
      paster rdf-export /path/to/store/output
    '''
    summary = __doc__.split('\n')[0]
    usage = __doc__

    def command(self):
        self._load_config()

        if not self.args:
            # default to run
            print RDFExport.__doc__
        else:
            self.export_datasets( self.args[0] )

    def export_datasets(self, out_folder):
        '''
        Export datasets as RDF to an output folder.
        '''
        import urlparse
        import urllib2
        import pylons.config as config
        import ckan.model as model
        import ckan.logic as logic
        import ckan.lib.helpers as h

        # Create output folder if not exists
        if not os.path.isdir( out_folder ):
            os.makedirs( out_folder )

        fetch_url = config['ckan.site_url']
        user = logic.get_action('get_site_user')({'model': model, 'ignore_auth': True}, {})
        context = {'model': model, 'session': model.Session, 'user': user['name']}
        dataset_names = logic.get_action('package_list')(context, {})
        for dataset_name in dataset_names:
            dd = logic.get_action('package_show')(context, {'id':dataset_name })
            if not dd['state'] == 'active':
                continue

            url = h.url_for( controller='package',action='read',
                                                  id=dd['name'])

            url = urlparse.urljoin(fetch_url, url[1:]) + '.rdf'
            try:
                fname = os.path.join( out_folder, dd['name'] ) + ".rdf"
                r = urllib2.urlopen(url).read()
                with open(fname, 'wb') as f:
                    f.write(r)
            except IOError, ioe:
                sys.stderr.write( str(ioe) + "\n" )




class Sysadmin(CkanCommand):
    '''Gives sysadmin rights to a named user

    Usage:
      sysadmin                      - lists sysadmins
      sysadmin list                 - lists sysadmins
      sysadmin add <user-name>      - add a user as a sysadmin
      sysadmin remove <user-name>   - removes user from sysadmins
    '''

    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 2
    min_args = 0

    def command(self):
        self._load_config()
        import ckan.model as model

        cmd = self.args[0] if self.args else None
        if cmd == None or cmd == 'list':
            self.list()
        elif cmd == 'add':
            self.add()
        elif cmd == 'remove':
            self.remove()
        else:
            print 'Command %s not recognized' % cmd

    def list(self):
        import ckan.model as model
        print 'Sysadmins:'
        sysadmins = model.Session.query(model.SystemRole).filter_by(role=model.Role.ADMIN)
        print 'count = %i' % sysadmins.count()
        for sysadmin in sysadmins:
            user_or_authgroup = sysadmin.user or sysadmin.authorized_group
            assert user_or_authgroup, 'Could not extract entity with this priviledge from: %r' % sysadmin
            print '%s name=%s id=%s' % (user_or_authgroup.__class__.__name__,
                                        user_or_authgroup.name,
                                        user_or_authgroup.id)

    def add(self):
        import ckan.model as model

        if len(self.args) < 2:
            print 'Need name of the user to be made sysadmin.'
            return
        username = self.args[1]

        user = model.User.by_name(unicode(username))
        if not user:
            print 'User "%s" not found' % username
            makeuser = raw_input('Create new user: %s? [y/n]' % username)
            if makeuser == 'y':
                password = UserCmd.password_prompt()
                print('Creating %s user' % username)
                user = model.User(name=unicode(username),
                                  password=password)
            else:
                print 'Exiting ...'
                return
        model.add_user_to_role(user, model.Role.ADMIN, model.System())
        model.repo.commit_and_remove()
        print 'Added %s as sysadmin' % username

    def remove(self):
        import ckan.model as model

        if len(self.args) < 2:
            print 'Need name of the user to be made sysadmin.'
            return
        username = self.args[1]

        user = model.User.by_name(unicode(username))
        if not user:
            print 'Error: user "%s" not found!' % username
            return
        model.remove_user_from_role(user, model.Role.ADMIN, model.System())
        model.repo.commit_and_remove()


class UserCmd(CkanCommand):
    '''Manage users

    Usage:
      user                            - lists users
      user list                       - lists users
      user <user-name>                - shows user properties
      user add <user-name> [apikey=<apikey>] [password=<password>]
                                      - add a user (prompts for password if
                                        not supplied)
      user setpass <user-name>        - set user password (prompts)
      user remove <user-name>         - removes user from users
      user search <query>             - searches for a user name
    '''
    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 4
    min_args = 0

    def command(self):
        self._load_config()
        import ckan.model as model

        if not self.args:
            self.list()
        else:
            cmd = self.args[0]
            if cmd == 'add':
                self.add()
            elif cmd == 'remove':
                self.remove()
            elif cmd == 'search':
                self.search()
            elif cmd == 'setpass':
                self.setpass()
            elif cmd == 'list':
                self.list()
            else:
                self.show()

    def get_user_str(self, user):
        user_str = 'name=%s' % user.name
        if user.name != user.display_name:
            user_str += ' display=%s' % user.display_name
        return user_str

    def list(self):
        import ckan.model as model
        print 'Users:'
        users = model.Session.query(model.User)
        print 'count = %i' % users.count()
        for user in users:
            print self.get_user_str(user)

    def show(self):
        import ckan.model as model

        username = self.args[0]
        user = model.User.get(unicode(username))
        print 'User: \n', user

    def setpass(self):
        import ckan.model as model

        if len(self.args) < 2:
            print 'Need name of the user.'
            return
        username = self.args[1]
        user = model.User.get(username)
        print('Editing user: %r' % user.name)

        password = self.password_prompt()
        user.password = password
        model.repo.commit_and_remove()
        print 'Done'

    def search(self):
        import ckan.model as model

        if len(self.args) < 2:
            print 'Need user name query string.'
            return
        query_str = self.args[1]

        query = model.User.search(query_str)
        print '%i users matching %r:' % (query.count(), query_str)
        for user in query.all():
            print self.get_user_str(user)

    @classmethod
    def password_prompt(cls):
        import getpass
        password1 = None
        while not password1:
            password1 = getpass.getpass('Password: ')
        password2 = getpass.getpass('Confirm password: ')
        if password1 != password2:
            print 'Passwords do not match'
            sys.exit(1)
        return password1

    def add(self):
        import ckan.model as model

        if len(self.args) < 2:
            print 'Need name of the user.'
            return
        username = self.args[1]
        user = model.User.by_name(unicode(username))
        if user:
            print 'User "%s" already found' % username
            sys.exit(1)

        # parse args
        apikey = None
        password = None
        args = self.args[2:]
        if len(args) == 1 and not (args[0].startswith('password') or \
                                   args[0].startswith('apikey')):
            # continue to support the old syntax of just supplying
            # the apikey
            apikey = args[0]
        else:
            # new syntax: password=foo apikey=bar
            for arg in args:
                split = arg.find('=')
                if split == -1:
                    split = arg.find(' ')
                    if split == -1:
                        raise ValueError('Could not parse arg: %r (expected "--<option>=<value>)")' % arg)
                key, value = arg[:split], arg[split+1:]
                if key == 'password':
                    password = value
                elif key == 'apikey':
                    apikey = value
                else:
                    raise ValueError('Could not parse arg: %r (expected password/apikey argument)' % arg)

        if not password:
            password = self.password_prompt()

        print('Creating user: %r' % username)


        user_params = {'name': unicode(username),
                       'password': password}
        if apikey:
            user_params['apikey'] = unicode(apikey)
        user = model.User(**user_params)
        model.Session.add(user)
        model.repo.commit_and_remove()
        user = model.User.by_name(unicode(username))
        print user

    def remove(self):
        import ckan.model as model

        if len(self.args) < 2:
            print 'Need name of the user.'
            return
        username = self.args[1]

        user = model.User.by_name(unicode(username))
        if not user:
            print 'Error: user "%s" not found!' % username
            return
        user.delete()
        model.repo.commit_and_remove()
        print('Deleted user: %s' % username)


class GroupCmd(CkanCommand):
    '''Manage groups within CKAN

    Usage:

        Info for groups:
            group list
            group <group-name>   - shows properties for the group
            group search <query> - Finds groups whose name matches the query

        Adding
            If the group already exists but is marked deleted, you
            should specify force=true at the end of the command

            group add <group-name> "<description>" <type> [force=true]

            You can add a user to a group using the following where role
            is either 'editor' or 'admin' :

            group adduser <group-name> <username> <role>

        Changing
            To change the name (url) to the group you can use the following
            command to do so.  It will force a re-index of all of the datasets
            associated with the group.

            You can optionally change the title of the group

            group update <old-group-name> <new-group-name> [title]

        Removing
            Removes the named group by setting its state to deleted

            group remove <group-name>

            To really remove a group (by deleting it entirely) you should
            use, but be careful as there is no check and no undo.

            group purge <group-name>

            You can remove a user from a group with:

            group removeuser <group-name> <username>
    '''
    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 5
    min_args = 0

    def command(self):
        self._load_config()
        import ckan.model as model

        if not self.args:
            print self.usage
        else:
            cmd = self.args[0].lower()
            if cmd == 'add':
                self.add()
            if cmd == 'adduser':
                self.add_user()
            elif cmd == 'remove':
                self.remove()
            elif cmd == 'removeuser':
                self.remove_user()
            elif cmd == 'search':
                self.search()
            elif cmd == 'list':
                self.list()
            elif cmd == 'show':
                self.show()
            elif cmd == 'purge':
                self.purge()
            elif cmd == 'update':
                self.update()                

    def get_group_str(self, group):
        return "title={0}, name={1}, type={2}, state={3}".format(group.title,group.name,
            group.type,group.state)

    def purge(self):
        from ckan import plugins
        import ckan.model as model

        groupname = self.args[1]
        group = model.Group.by_name(groupname)
        if not group:
            print "Cannot find the group '{g}'".format(g=groupname)
            return

        members = model.Session.query(model.Member).filter(model.Member.group_id==group.id).\
            filter(model.Member.state=='active').filter(model.Member.table_name=='package')
        if members.count() > 0:
            model.repo.new_revision()
            for m in members.all():
                m.delete()
            model.repo.commit_and_remove()

        plugins.load('synchronous_search')
        rev = model.repo.new_revision()
        group.purge()
        model.repo.commit_and_remove()
        print '%s purged' % groupname


    def list(self):
        """ Lists all groups, regardless of state """

        import ckan.model as model

        print 'Groups:'
        groups = model.Session.query(model.Group)
        print 'count = %i' % groups.count()
        for group in groups:
            print self.get_group_str(group)

    def _display_group(self, group):
        """ Displays some useful information about the group """

        import ckan.model as model

        print '*' * 40, "info"
        print "Title:       {title}".format(title=group.title)
        print "Type:        {type}".format(type=group.type or "default")
        print "Name:        {name}".format(name=group.name)
        print "Description: {desc}".format(desc=group.description)
        print "Image URL:   {u}".format(u=group.image_url)
        print "Status:      {s}".format(s=group.state)

        print '*' * 40, "stats"
        admin_count = group.members_of_type(model.User, 'admin').count()
        print "Admins: {uc}".format(uc=admin_count)
        if admin_count:
            print "    -> ",
            print ', '.join(u.name for u in group.members_of_type(model.User, 'admin').all())

        editor_count = group.members_of_type(model.User, 'editor').count()
        print "Editors: {uc}".format(uc=editor_count)
        if editor_count:
            print "    -> ",
            print ', '.join(u.name for u in group.members_of_type(model.User, 'editor').all())

        print "Dataset count: {dc}".format(dc=group.members_of_type(model.Package).count())


    def update(self):
        """ Changes the slug for the group """
        import ckan.model as model
        import ckan.lib.search as search

        if len(self.args) < 3:
            print "Please specify the old and new group names with an optional new title"
            print self.usage
            return

        title = None
        if len(self.args) == 4:
            title = self.args[3]

        oldgroupname = self.args[1]
        newgroupname = self.args[2]        
        print "Converting '{0}' to '{1}'".format(oldgroupname, newgroupname)

        existing = model.Group.by_name(newgroupname)
        if existing:
            print "'{0}' is already in user, please choose another name".format(newgroupname)
        
        group = model.Group.by_name(oldgroupname)
        if not group:
            print "Group {g} not found".format(g=oldgroupname)
            return

        model.repo.new_revision()
        group.name = newgroupname
        x = sum( 1 for k in group.extras.keys() if k.startswith('previous-name-') )
        group.extras['previous-name-%d' % (x+1)] = oldgroupname
        if title:
            group.extras['previous-title'] = group.title
            group.title = title
        group.save()

        print "Updating search index ...."
        members = model.Session.query(model.Member).filter(model.Member.group_id==group.id).\
            filter(model.Member.state=='active').filter(model.Member.table_name=='package')
        for member in members:
            search.rebuild(member.table_id)

        self._display_group(group)


    def show(self):
        """ Shows information about a single group """
        import ckan.model as model

        if len(self.args) < 2:
            print "Please specify the groupname"
            print self.usage
            return

        groupname = self.args[1]
        group = model.Group.by_name(groupname)
        if group:
            self._display_group(group)
        else:
            print "Group {g} not found".format(g=groupname)


    def search(self):
        """ Finds a group based on the supplied name and an ilike lookup """
        import ckan.model as model

        if len(self.args) < 2:
            print 'Need group name query string.'
            print self.usage
            return
        query_str = self.args[1].lower()

        query = model.Session.query(model.Group).\
            filter(model.Group.title.ilike('%%%s%%' % query_str))

        print '%i groups matching %r:' % (query.count(), query_str)
        for group in query.all():
            print self.get_group_str(group)

    def add_user(self):
        """ Adds a user to the group with the specific role (capacity) """
        import ckan.model as model
        # group adduser <groupname> <username> <role>

        if len(self.args) != 4:
            print "You must specify the groupname and the username as well as the role"
            print self.usage
            return

        groupname, username, role = self.args[1:]

        group = model.Group.by_name(unicode(groupname))
        if not group:
            print "Could not find group '{name}'".format(name=groupname)
            return

        user = model.User.by_name(unicode(username))
        if not user:
            print "Could not find user '{name}'".format(name=username)
            return

        if not role in ['editor', 'admin']:
            print "Role can only be 'editor', or 'admin'"
            return

        model.repo.new_revision()

        # If the user is already a member of this group, then change the capacity
        # and update the membership.
        members = model.Session.query(model.Member).filter(model.Member.group_id==group.id).\
            filter(model.Member.state=='active').filter(model.Member.table_name=='user').\
            filter(model.Member.table_id==user.id)
        if members.count() > 0:
            print "User {u} is already a member of {g}, checking capacity".\
                format(u=username, g=groupname)
            m = members[0]
            m.capacity = role
            model.Session.add(m)
            model.repo.commit_and_remove()
            self._display_group(group)
            return

        member = model.Member(group=group, table_name='user', table_id=user.id, capacity=role)
        model.Session.add(member)
        model.repo.commit_and_remove()

        # Show the group so that we can see the change.
        self._display_group(group)


    def add(self):
        """ Adds a new group, and provides a means to change the state if
            the group already exists """
        import ckan.model as model

        # need title, type as a minimum
        if len(self.args) < 4:
            print 'Need name, title and type of the group'
            print self.usage
            return

        groupname = self.args[1]
        grouptitle = self.args[2]
        grouptype = self.args[3]
        force = len(self.args) == 5 and self.args[4][:5] == 'force' and self.args[4][6:] == 'true'

        group = model.Group.by_name(unicode(groupname))
        if group:
            if group.state =='deleted' and not force:
                print "Group %s exists, but is deleted, use 'force=true' to reinstate" % group.name
                sys.exit(1)
            elif group.state == 'deleted' and force:
                print "Changing the status of the group to 'active'"
                group.state = 'active'
                model.repo.new_revision()
                model.Session.add(group)
                model.repo.commit_and_remove()
                self._display_group(group)
                return
            else:
                print 'Group "%s" already exists' % groupname
                return

        print('Creating group: %r' % groupname)

        group_params = {'name': unicode(groupname),
                        'title': grouptitle,
                        'type': grouptype}
        model.repo.new_revision()
        group = model.Group(**group_params)
        model.Session.add(group)
        model.repo.commit_and_remove()
        group = model.Group.by_name(unicode(groupname))
        if not group:
            print("Something went wrong, unable to find the group after creation")

    def remove(self):
        """ Sets the state of the named group to deleted """
        import ckan.model as model

        if len(self.args) < 2:
            print 'Need name of the group.'
            print self.usage
            return

        groupname = self.args[1]

        rev = model.repo.new_revision()
        group = model.Group.by_name(unicode(groupname))
        if not group:
            print 'Error: group "%s" not found!' % groupname
            return
        group.delete()
        model.repo.commit_and_remove()
        print('Deleted group: %s' % groupname)

    def remove_user(self):
        """ Removes a user entirely from the group """
        import ckan.model as model
        # group removeuser <groupname> <username>

        if len(self.args) != 3:
            print "You must specify the groupname and the username"
            print self.usage
            return

        groupname, username = self.args[1:]

        group = model.Group.by_name(unicode(groupname))
        if not group:
            print "Could not find group '{name}'".format(name=groupname)
            return

        user = model.User.by_name(unicode(username))
        if not user:
            print "Could not find user '{name}'".format(name=username)
            return

        # If the user is already a member of this group, then change the capacity
        # and update the membership.
        members = model.Session.query(model.Member).filter(model.Member.group_id==group.id).\
            filter(model.Member.state=='active').filter(model.Member.table_name=='user').\
            filter(model.Member.table_id==user.id)
        if members.count() > 0:
            model.repo.new_revision()
            for m in members.all():
                m.delete()
            model.repo.commit_and_remove()
            print "'{u}' has been removed from '{g}'".format(u=username, g=groupname)

            # Show the group so that we can see the change.
            self._display_group(group)

        else:
            print "'{u}' is not in the group '{g}'".format(u=username, g=groupname)
            return


class DatasetCmd(CkanCommand):
    '''Manage datasets

    Usage:
      dataset <dataset-name/id>          - shows dataset properties
      dataset show <dataset-name/id>     - shows dataset properties
      dataset list                       - lists datasets
      dataset addtogroup <dataset-name/id> <groupname>   - Adds dataset to the group
      dataset removefromgroup <dataset-name/id> <groupname>   - Removes dataset from the group
      dataset delete <dataset-name/id>   - changes dataset state to 'deleted'
      dataset purge <dataset-name/id>    - removes dataset from db entirely
    '''
    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 3
    min_args = 0

    def command(self):
        self._load_config()
        import ckan.model as model

        if not self.args:
            print self.usage
        else:
            cmd = self.args[0]
            if cmd == 'delete':
                self.delete(self.args[1])
            elif cmd == 'purge':
                self.purge(self.args[1])
            elif cmd == 'list':
                self.list()
            elif cmd == 'show':
                self.show(self.args[1])
            elif cmd == 'addtogroup':
                self.add_to_group(self.args[1], self.args[2])
            elif cmd == 'removefromgroup':
                self.remove_from_group(self.args[1], self.args[2])
            else:
                self.show(self.args[0])

    def add_to_group(self, datasetname, groupname):
        import ckan.model as model

        group = model.Group.by_name(groupname)
        if not group:
            print "Could not find group '{g}'".format(g=groupname)
            return

        dataset = model.Package.by_name(datasetname)
        if not dataset:
            print "Could not find dataset '{d}'".format(d=datasetname)
            return

        # Check if this dataset is already in the group, and bail if so.
        members = model.Session.query(model.Member).filter(model.Member.group_id==group.id).\
            filter(model.Member.state=='active').filter(model.Member.table_name=='package').\
            filter(model.Member.table_id==dataset.id)
        if members.count() > 0:
            print "Dataset '{d}' is already in group '{g}'".format(d=datasetname, g=groupname)
            return

        print "Adding {d} to {g}".format(d=datasetname, g=groupname)

        model.repo.new_revision()
        member = model.Member(group=group, table_name='package', table_id=dataset.id, capacity='public')
        model.Session.add(member)
        model.repo.commit_and_remove()


    def remove_from_group(self, datasetname, groupname):
        import ckan.model as model
        print "Removing {d} from {g}".format(d=datasetname, g=groupname)

        group = model.Group.by_name(groupname)
        if not group:
            print "Could not find group '{g}'".format(g=groupname)
            return

        dataset = model.Package.by_name(datasetname)
        if not dataset:
            print "Could not find dataset '{d}'".format(d=datasetname)
            return

        members = model.Session.query(model.Member).filter(model.Member.group_id==group.id).\
            filter(model.Member.state=='active').filter(model.Member.table_name=='package').\
            filter(model.Member.table_id==dataset.id)
        if members.count() == 0:
            print "Dataset '{d}' is not in group '{g}'".format(d=datasetname, g=groupname)
            return

        for m in members.all():
            model.repo.new_revision()
            for m in members.all():
                m.delete()
            model.repo.commit_and_remove()


    def list(self):
        import ckan.model as model
        print 'Datasets:'
        datasets = model.Session.query(model.Package)
        print 'count = %i' % datasets.count()
        for dataset in datasets:
            state = ('(%s)' % dataset.state) if dataset.state != 'active' \
                    else ''
            print '%s %s %s' % (dataset.id, dataset.name, state)

    def _get_dataset(self, dataset_ref):
        import ckan.model as model
        dataset = model.Package.get(unicode(dataset_ref))
        if not dataset:
            print 'Could not find dataset matching reference: %r' % dataset_ref
            sys.exit(1)
        return dataset

    def show(self, dataset_ref):
        import pprint
        dataset = self._get_dataset(dataset_ref)
        pprint.pprint(dataset.as_dict())

    def delete(self, dataset_ref):
        from ckan import plugins
        import ckan.model as model
        dataset = self._get_dataset(dataset_ref)
        old_state = dataset.state

        plugins.load('synchronous_search')
        rev = model.repo.new_revision()
        dataset.delete()
        model.repo.commit_and_remove()
        dataset = self._get_dataset(dataset_ref)
        print '%s %s -> %s' % (dataset.name, old_state, dataset.state)

    def purge(self, dataset_ref):
        from ckan import plugins
        import ckan.model as model
        dataset = self._get_dataset(dataset_ref)
        name = dataset.name

        plugins.load('synchronous_search')
        rev = model.repo.new_revision()
        dataset.purge()
        model.repo.commit_and_remove()
        print '%s purged' % name

class ResourceCmd(CkanCommand):
    '''Manage resources

    Usage:
      resource <resource-name/id>          - shows resource properties
      resource show <resource-name/id>     - shows resource properties
    '''
    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 3
    min_args = 0

    def command(self):
        self._load_config()
        import ckan.model as model

        if not self.args:
            print self.usage
        else:
            cmd = self.args[0]
            if cmd == 'delete':
                self.delete(self.args[1])
            elif cmd == 'purge':
                self.purge(self.args[1])
            elif cmd == 'list':
                self.list()
            elif cmd == 'show':
                self.show(self.args[1])
            else:
                self.show(self.args[0])

    def _get_resource(self, resource_ref):
        import ckan.model as model
        resource = model.Resource.get(unicode(resource_ref))
        assert resource, 'Could not find resource matching reference: %r' % resource_ref
        if isinstance(resource, model.ResourceRevision):
            return resource.continuity
        return resource

    def show(self, resource_ref):
        import pprint
        resource = self._get_resource(resource_ref)
        res_dict = resource.as_dict()
        # package name is very useful to know
        res_dict['package'] = resource.resource_group.package.name if resource.resource_group else None
        pprint.pprint(res_dict)

class Celery(CkanCommand):
    '''Celery daemon

    Usage:
        celeryd       - run the celery daemon
        celeryd run   - run the celery daemon
        celeryd run concurrency=1 - run the celery daemon with argument 'concurrency'
        celeryd view [num] - view queue stats and the <num> most recent tasks
        celeryd clean - delete all tasks in the queue
        celeryd clean-done - delete tasks in the queue that have been done
    '''
    min_args = 0
    summary = __doc__.split('\n')[0]
    usage = __doc__

    def __init__(self, name):
        super(Celery,self).__init__(name)
        self.parser.add_option('-q', '--queue',
                               action='store',
                               dest='queue',
                               help="Refer to a particular queue")

    def command(self):
        self._load_config(load_environment=False)
        self.session = self.get_celery_db_session()
        self.queues = self.get_queues()

        if not self.args:
            self.run_()
        else:
            cmd = self.args[0]
            if cmd == 'run':
                self.run_()
            elif cmd == 'view':
                if len(self.args) > 1:
                    num = int(self.args[1])
                else:
                    num = 1
                self.view(num)
            elif cmd == 'clean':
                self.clean()
            elif cmd == 'clean-done':
                self.clean(include_tasks_not_done=False)
            else:
                print 'Command %s not recognized' % cmd
                sys.exit(1)

    def run_(self):
        assert self.options.queue, 'Please specifiy a --queue from: %r' % self.queues.keys()
        os.environ['CKAN_CONFIG'] = os.path.abspath(self.options.config)
        from ckan.lib.celery_app import celery
        celery_args = ['--%s' % arg for arg in self.args[1:]]
        for arg in self.args:
            if arg.startswith('loglevel'):
                break
        else:
            celery_args.append('--loglevel=INFO')
        if self.options.queue:
            celery_args.append('--queue=%s' % self.options.queue)
        celery.worker_main(argv=['celeryd'] + celery_args)

    def get_celery_db_session(self):
        '''
        Returns an SQLAlchemy session for the db with the Celery
        broker and results tables.

        NB Often this is the same db as CKAN, but not always.
        '''
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker
        from pylons import config as pylons_config

        sqlalchemy_url = pylons_config.get('celery.sqlalchemy.url') or \
                         pylons_config.get('sqlalchemy.url')
        engine = create_engine(sqlalchemy_url)
        Session = sessionmaker(bind=engine)()
        return Session

    def get_queues(self):
        from kombu.transport.sqlalchemy.models import Queue
        return dict([(queue.name, queue.id) \
                     for queue in self.session.query(Queue) \
                     if 'celeryd.pidbox' not in queue.name])

    def view(self, num):
        import pprint
        import ckan.model as model
        from ckan.lib.helpers import json
        from kombu.transport.sqlalchemy.models import Message
        from kombu.serialization import registry
        from kombu.transport.virtual import Base64

        print 'Queues: %s' % self.queues.keys()
        queues = [self.options.queue] if self.options.queue else self.queues.keys()
        for queue in queues:
            print '\nQueue: %s' % queue

            # summary
            q = self.session.query(Message) \
                .filter_by(queue_id=self.queues[queue])
            q_visible = q.filter_by(visible=True)
            print 'Messages on the queue:'
            print '%i total' % q.count()
            print '%i not yet processed ("visible")' % q_visible.count()

            # last messages
            if num and q.count():
                print '%i newest messages:\n' % num
            for message in q.order_by(Message.sent_at.desc()).limit(num):
                if message.visible:
                    print 'Task %i: Not yet processed' % (message.id)
                else:
                    print 'Task %i: Processed at:%s' % (message.id, message.sent_at.strftime('%Y-%m-%d %H:%M'))
                payload_dict = json.loads(message.payload)
                body = payload_dict['body']
                if body:
                    body = Base64().decode(body)
                payload = registry.decode(
                    body,
                    content_type=payload_dict['content-type'],
                    content_encoding=payload_dict['content-encoding'])
                pprint.pprint(payload)
                print # newline

    def clean(self, include_tasks_not_done=True):
        import ckan.model as model
        import pprint
        assert self.options.queue, 'Please specifiy a --queue from: %r' % self.queues.keys()
        Session = self.session
        for table in ('broker', 'status'):
            table_printable = 'table:%s' % table
            if table == 'broker':
                table_printable += ' queue:%s' % self.options.queue
            if include_tasks_not_done:
                domain = 'from kombu_message where queue_id=%s' \
                             % self.queues[self.options.queue] \
                         if table=='broker' else \
                         'from celery_taskmeta'
            else:
                domain = 'from kombu_message where visible=false and queue_id=%s' \
                           % self.queues[self.options.queue] \
                         if table=='broker' else \
                         'from celery_taskmeta where status = "success"'
            tasks_initially = Session.execute('select * %s' % domain).rowcount
            if not tasks_initially:
                print 'No tasks to delete from %s' % table_printable
                continue
            query = Session.execute('delete %s' % domain)
            tasks_afterwards = Session.execute('select * %s' % domain).rowcount
            print '%i of %i %stasks deleted from %s' % \
                  (tasks_initially - tasks_afterwards,
                   tasks_initially,
                   ' done' if not include_tasks_not_done else '',
                   table_printable)
            if tasks_afterwards:
                print 'WARNING: Failed to delete all tasks from %s' % table_printable
            Session.commit()

class Ratings(CkanCommand):
    '''Manage the ratings stored in the db

    Usage:
      ratings count                 - counts ratings
      ratings clean                 - remove all ratings
      ratings clean-anonymous       - remove only anonymous ratings
    '''

    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 1
    min_args = 1

    def command(self):
        self._load_config()
        import ckan.model as model

        cmd = self.args[0]
        if cmd == 'count':
            self.count()
        elif cmd == 'clean':
            self.clean()
        elif cmd == 'clean-anonymous':
            self.clean(user_ratings=False)
        else:
            print 'Command %s not recognized' % cmd

    def count(self):
        import ckan.model as model
        q = model.Session.query(model.Rating)
        print "%i ratings" % q.count()
        q = q.filter(model.Rating.user_id == None)
        print "of which %i are anonymous ratings" % q.count()

    def clean(self, user_ratings=True):
        import ckan.model as model
        q = model.Session.query(model.Rating)
        print "%i ratings" % q.count()
        if not user_ratings:
            q = q.filter(model.Rating.user_id == None)
            print "of which %i are anonymous ratings" % q.count()
        ratings = q.all()
        for rating in ratings:
            rating.purge()
        model.repo.commit_and_remove()

class Tracking(CkanCommand):
    '''Update tracking statistics

    Usage:
      tracking   - update tracking stats
    '''

    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 1
    min_args = 0

    def command(self):
        self._load_config()
        import ckan.model as model
        engine = model.meta.engine

        if len(self.args) == 1:
            # Get summeries from specified date
            start_date = datetime.datetime.strptime(self.args[0], '%Y-%m-%d')
        else:
            # No date given. See when we last have data for and get data
            # from 2 days before then in case new data is available.
            # If no date here then use 2010-01-01 as the start date
            sql = '''SELECT tracking_date from tracking_summary
                     ORDER BY tracking_date DESC LIMIT 1;'''
            result = engine.execute(sql).fetchall()
            if result:
                start_date = result[0]['tracking_date']
                start_date += datetime.timedelta(-2)
                # convert date to datetime
                combine = datetime.datetime.combine
                start_date = combine(start_date, datetime.time(0))
            else:
                start_date = datetime.datetime(2011, 1, 1)
        end_date = datetime.datetime.now()

        while start_date < end_date:
            stop_date = start_date + datetime.timedelta(1)
            self.update_tracking(engine, start_date)
            print 'tracking updated for %s' % start_date
            start_date = stop_date

    def update_tracking(self, engine, summary_date):
        PACKAGE_URL = '/dataset/'
        # clear out existing data before adding new
        sql = '''DELETE FROM tracking_summary
                 WHERE tracking_date='%s'; ''' % summary_date
        engine.execute(sql)

        sql = '''SELECT DISTINCT url, user_key,
                     CAST(access_timestamp AS Date) AS tracking_date,
                     tracking_type INTO tracking_tmp
                 FROM tracking_raw
                 WHERE CAST(access_timestamp as Date)='%s';

                 INSERT INTO tracking_summary
                   (url, count, tracking_date, tracking_type)
                 SELECT url, count(user_key), tracking_date, tracking_type
                 FROM tracking_tmp
                 GROUP BY url, tracking_date, tracking_type;

                 DROP TABLE tracking_tmp;
                 COMMIT;''' % summary_date
        engine.execute(sql)

        # get ids for dataset urls
        sql = '''UPDATE tracking_summary t
                 SET package_id = COALESCE(
                        (SELECT id FROM package p
                        WHERE t.url =  %s || p.name)
                     ,'~~not~found~~')
                 WHERE t.package_id IS NULL
                 AND tracking_type = 'page';'''
        engine.execute(sql, PACKAGE_URL)

        # update summary totals for resources
        sql = '''UPDATE tracking_summary t1
                 SET running_total = (
                    SELECT sum(count)
                    FROM tracking_summary t2
                    WHERE t1.url = t2.url
                    AND t2.tracking_date <= t1.tracking_date
                 ) + t1.count
                 ,recent_views = (
                    SELECT sum(count)
                    FROM tracking_summary t2
                    WHERE t1.url = t2.url
                    AND t2.tracking_date <= t1.tracking_date AND t2.tracking_date >= t1.tracking_date - 14
                 ) + t1.count
                 WHERE t1.running_total = 0 AND tracking_type = 'resource';'''
        engine.execute(sql)

        # update summary totals for pages
        sql = '''UPDATE tracking_summary t1
                 SET running_total = (
                    SELECT sum(count)
                    FROM tracking_summary t2
                    WHERE t1.package_id = t2.package_id
                    AND t2.tracking_date <= t1.tracking_date
                 ) + t1.count
                 ,recent_views = (
                    SELECT sum(count)
                    FROM tracking_summary t2
                    WHERE t1.package_id = t2.package_id
                    AND t2.tracking_date <= t1.tracking_date AND t2.tracking_date >= t1.tracking_date - 14
                 ) + t1.count
                 WHERE t1.running_total = 0 AND tracking_type = 'page'
                 AND t1.package_id IS NOT NULL
                 AND t1.package_id != '~~not~found~~';'''
        engine.execute(sql)

class PluginInfo(CkanCommand):
    ''' Provide info on installed plugins.
    '''

    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 0
    min_args = 0

    def command(self):
        self.get_info()

    def get_info(self):
        ''' print info about current plugins from the .ini file'''
        import ckan.plugins as p
        self._load_config()
        interfaces = {}
        plugins = {}
        for name in dir(p):
            item = getattr(p, name)
            try:
                if issubclass(item, p.Interface):
                    interfaces[item] = {'class' : item}
            except TypeError:
                pass

        for interface in interfaces:
            for plugin in p.PluginImplementations(interface):
                name = plugin.name
                if name not in plugins:
                    plugins[name] = {'doc' : plugin.__doc__,
                                     'class' : plugin,
                                     'implements' : []}
                plugins[name]['implements'].append(interface.__name__)

        for plugin in plugins:
            p = plugins[plugin]
            print plugin + ':'
            print '-' * (len(plugin) + 1)
            if p['doc']:
                print p['doc']
            print 'Implements:'
            for i in p['implements']:
                extra = None
                if i == 'ITemplateHelpers':
                    extra = self.template_helpers(p['class'])
                if i == 'IActions':
                    extra = self.actions(p['class'])
                print '    %s' % i
                if extra:
                    print extra
            print


    def actions(self, cls):
        ''' Return readable action function info. '''
        actions = cls.get_actions()
        return self.function_info(actions)

    def template_helpers(self, cls):
        ''' Return readable helper function info. '''
        helpers = cls.get_helpers()
        return self.function_info(helpers)

    def function_info(self, functions):
        ''' Take a dict of functions and output readable info '''
        import inspect
        output = []
        for function_name in functions:
            fn = functions[function_name]
            args_info = inspect.getargspec(fn)
            params = args_info.args
            num_params = len(params)
            if args_info.varargs:
                params.append('*' + args_info.varargs)
            if args_info.keywords:
                params.append('**' + args_info.keywords)
            if args_info.defaults:
                offset = num_params - len(args_info.defaults)
                for i, v in enumerate(args_info.defaults):
                    params[i + offset] = params[i + offset] + '=' + repr(v)
            # is this a classmethod if so remove the first parameter
            if inspect.ismethod(fn) and inspect.isclass(fn.__self__):
                params = params[1:]
            params = ', '.join(params)
            output.append('        %s(%s)' % (function_name, params))
            # doc string
            if fn.__doc__:
                bits = fn.__doc__.split('\n')
                for bit in bits:
                    output.append('            %s' % bit)
        return ('\n').join(output)


class CreateTestDataCommand(CkanCommand):
    '''Create test data in the database.
    Tests can also delete the created objects easily with the delete() method.

    create-test-data              - annakarenina and warandpeace
    create-test-data search       - realistic data to test search
    create-test-data gov          - government style data
    create-test-data family       - package relationships data
    create-test-data user         - create a user 'tester' with api key 'tester'
    create-test-data translations - annakarenina, warandpeace, and some test
                                    translations of terms
    create-test-data vocabs  - annakerenina, warandpeace, and some test
                               vocabularies

    '''
    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 1
    min_args = 0

    def command(self):
        self._load_config()
        self._setup_app()
        from ckan import plugins
        plugins.load('synchronous_search') # so packages get indexed
        from create_test_data import CreateTestData

        if self.args:
            cmd = self.args[0]
        else:
            cmd = 'basic'
        if self.verbose:
            print 'Creating %s test data' % cmd
        if cmd == 'basic':
            CreateTestData.create_basic_test_data()
        elif cmd == 'user':
            CreateTestData.create_test_user()
            print 'Created user %r with password %r and apikey %r' % ('tester',
                    'tester', 'tester')
        elif cmd == 'search':
            CreateTestData.create_search_test_data()
        elif cmd == 'gov':
            CreateTestData.create_gov_test_data()
        elif cmd == 'family':
            CreateTestData.create_family_test_data()
        elif cmd == 'translations':
            CreateTestData.create_translations_test_data()
        elif cmd == 'vocabs':
            CreateTestData.create_vocabs_test_data()
        else:
            print 'Command %s not recognized' % cmd
            raise NotImplementedError
        if self.verbose:
            print 'Creating %s test data: Complete!' % cmd

class Profile(CkanCommand):
    '''Code speed profiler
    Provide a ckan url and it will make the request and record
    how long each function call took in a file that can be read
    by runsnakerun.

    Usage:
       profile {url}

    e.g. profile /data/search

    The result is saved in profile.data.search
    To view the profile in runsnakerun:
       runsnakerun ckan.data.search.profile

    You may need to install python module: cProfile
    '''
    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = 1
    min_args = 1

    def _load_config_into_test_app(self):
        from paste.deploy import loadapp
        import paste.fixture
        if not self.options.config:
            msg = 'No config file supplied'
            raise self.BadCommand(msg)
        self.filename = os.path.abspath(self.options.config)
        if not os.path.exists(self.filename):
            raise AssertionError('Config filename %r does not exist.' % self.filename)
        fileConfig(self.filename)

        wsgiapp = loadapp('config:' + self.filename)
        self.app = paste.fixture.TestApp(wsgiapp)

    def command(self):
        self._load_config_into_test_app()

        import paste.fixture
        import cProfile
        import re

        url = self.args[0]

        def profile_url(url):
            try:
                res = self.app.get(url, status=[200], extra_environ={'REMOTE_USER': 'visitor'})
            except paste.fixture.AppError:
                print 'App error: ', url.strip()
            except KeyboardInterrupt:
                raise
            except:
                import traceback
                traceback.print_exc()
                print 'Unknown error: ', url.strip()

        output_filename = 'ckan%s.profile' % re.sub('[/?]', '.', url.replace('/', '.'))
        profile_command = "profile_url('%s')" % url
        cProfile.runctx(profile_command, globals(), locals(), filename=output_filename)
        print 'Written profile to: %s' % output_filename
